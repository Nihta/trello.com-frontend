var hasProp = Object.prototype.hasOwnProperty;

var subclass = function(child, parent) {
  for (var key in parent) {
    if (hasProp.call(parent, key)) {
      child[key] = parent[key];
    }
  }

  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;
};

var extendFactory = function(predicate) {
  return function(target) {
    var extenders = Array.prototype.slice.call(arguments, 1);

    for (var i = 0; i < extenders.length; i++) {
      var extender = extenders[i];
      for (var key in extender) {
        if (!hasProp.call(extender, key)) {
          continue;
        }
        if (predicate(target, key, extender)) {
          target[key] = extender[key];
        }
      }
    }

    return target;
  };
};

var extend = extendFactory(function() {
  return true;
});

var defaults = extendFactory(function(target, key) {
  return typeof target[key] === 'undefined';
});

// This takes a string as a name and some optional custom attributes and create
// and return an error class that can be used as a method similar to Error while
// still providing backtraces.
//
// Downside: the constructor.name will always be TrelloError. There is no way
// around this without duplicating this same constructor code everywhere. What
// this means is that if you are debugging in node inspector, it will be labeled
// "TrelloError" even though it has its own, specific name property.
module.exports = function(name, defaultAttributes, baseErrorClass) {
  if (baseErrorClass == null) {
    baseErrorClass = Error;
  }

  function TrelloError(message, attributes) {
    if (!(this instanceof TrelloError)) {
      var error = new TrelloError(message, attributes);
      // Make sure the stack trace does not include the "new TrelloError" call
      if (Error.captureStackTrace != null) {
        Error.captureStackTrace(error, arguments.callee);
      }
      return error;
    }

    Error.call(this);
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, arguments.callee);
    }

    // Explicitly set this because the default is ''. If we passed nothing, it
    // will be undefined and the defaults call has a chance to overwrite it.
    this.message = message;

    // Make sure we set this after the error call above
    defaults(this, attributes, defaultAttributes);

    // Now that the message was set through either the constructor or the error
    // defaults, we can encapsulate it behind a getter
    var _message = this.message || message;
    delete this.message;

    Object.defineProperty(this, 'message', {
      get: function() {
        return this.getMessage(_message);
      },
      set: function(value) {
        _message = value;
      }
    });
  }

  subclass(TrelloError, baseErrorClass);

  TrelloError.prototype.name = name;

  // You can override this method so that any reference to message (i.e., the
  // property, a toString() call, or a formatted stack) will be computed on the
  // fly with extra information in the attributes.
  TrelloError.prototype.getMessage = function(message) {
    return message;
  };

  TrelloError.prototype.toObject = function() {
    var result = {};

    for (var key in this) {
      if (!hasProp.call(this, key)) {
        continue;
      }
      result[key] = this[key];
    }

    return result;
  };

  TrelloError.prototype.toJSON = function() {
    return extend({
      message: this.message
    }, this.toObject());
  };

  return TrelloError;
};
