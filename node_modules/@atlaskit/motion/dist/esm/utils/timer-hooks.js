import { __read, __spread } from "tslib";
import { useCallback, useEffect, useRef } from 'react';
var getHookDeps = function (opts) {
    switch (opts.cleanup) {
        case 'next-effect':
            return undefined;
        case 'unmount':
        default:
            return [];
    }
};
/**
 * Will return request animation frame as a function which will clean itself up.
 */
export var useRequestAnimationFrame = function (opts) {
    if (opts === void 0) { opts = { cleanup: 'unmount' }; }
    var frames = useRef([]);
    useEffect(function () {
        return function () {
            if (frames.current.length) {
                frames.current.forEach(function (id) { return cancelAnimationFrame(id); });
                frames.current = [];
            }
        };
        // We dynamically set this so we either clean up on the next effect - or on unmount.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, getHookDeps(opts));
    return useCallback(function (handler) {
        var id = requestAnimationFrame(function (time) {
            frames.current = frames.current.filter(function (frameId) { return frameId !== id; });
            handler(time);
        });
        frames.current.push(id);
    }, []);
};
/**
 * Will return set  timeout as a function which will clean itself up.
 */
export var useSetTimeout = function (opts) {
    if (opts === void 0) { opts = { cleanup: 'unmount' }; }
    var timeouts = useRef([]);
    useEffect(function () {
        return function () {
            if (timeouts.current.length) {
                timeouts.current.forEach(function (id) { return clearTimeout(id); });
                timeouts.current = [];
            }
        };
        // We dynamically set this so we either clean up on the next effect - or on unmount.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, getHookDeps(opts));
    return useCallback(function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var id = setTimeout.apply(void 0, __spread([function () {
                timeouts.current = timeouts.current.filter(function (timeoutId) { return timeoutId !== id; });
                handler();
            }, timeout], args));
        timeouts.current.push(id);
    }, []);
};
//# sourceMappingURL=timer-hooks.js.map