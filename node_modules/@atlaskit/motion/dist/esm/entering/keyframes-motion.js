import { __assign, __read } from "tslib";
import React, { useEffect, useState } from 'react';
import { ClassNames, keyframes } from '@emotion/core';
import { prefersReducedMotion } from '../utils/accessibility';
import { largeDurationMs } from '../utils/durations';
import { useSetTimeout } from '../utils/timer-hooks';
import { useExitingPersistence } from './exiting-persistence';
import { useStaggeredEntrance } from './staggered-entrance';
/**
 * Used to multiply the initial duration for exiting motions.
 */
var EXITING_MOTION_MULTIPLIER = 0.5;
/**
 * This is the base INTERNAL component used for all other entering motions.
 * This does not need Javascript to execute on the client so it will run immediately
 * for any SSR rendered React apps before the JS has executed.
 */
var EnteringMotion = function (_a) {
    var children = _a.children, animationTimingFunction = _a.animationTimingFunction, enteringAnimation = _a.enteringAnimation, exitingAnimation = _a.exitingAnimation, isPaused = _a.isPaused, onFinishMotion = _a.onFinish, _b = _a.duration, duration = _b === void 0 ? largeDurationMs : _b;
    var staggered = useStaggeredEntrance();
    var _c = useExitingPersistence(), isExiting = _c.isExiting, onExitFinished = _c.onFinish, appear = _c.appear;
    var setTimeout = useSetTimeout();
    var paused = isPaused || !staggered.isReady;
    var delay = isExiting ? 0 : staggered.delay;
    var state = isExiting ? 'exiting' : 'entering';
    var _d = __read(useState(appear), 2), hasAnimationStyles = _d[0], setHasAnimationStyles = _d[1];
    useEffect(function () {
        // Tracking this to prevent changing state on an unmounted component
        var isCancelled = false;
        if (paused) {
            return;
        }
        // On initial mount if elements aren't set to animate on appear, we return early and callback
        if (!appear) {
            onFinishMotion && onFinishMotion(state);
            return;
        }
        // Elements may need animation styles back after initial mount (they could animate out)
        setHasAnimationStyles(true);
        setTimeout(function () {
            if (state === 'exiting') {
                onExitFinished && onExitFinished();
            }
            if (!isCancelled) {
                setHasAnimationStyles(false);
            }
            onFinishMotion && onFinishMotion(state);
        }, isExiting ? duration * EXITING_MOTION_MULTIPLIER : duration + delay);
        return function () {
            isCancelled = true;
        };
        // We ignore this for onFinishMotion as consumers could potentially inline the function
        // which would then trigger this effect every re-render.
        // We want to make it easier for consumers so we go down this path unfortunately.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [onExitFinished, state, isExiting, duration, delay, paused, setTimeout]);
    return (React.createElement(ClassNames, null, function (_a) {
        var css = _a.css;
        return children({
            ref: staggered.ref,
            className: hasAnimationStyles
                ? css(__assign({ animationName: "" + keyframes(isExiting
                        ? exitingAnimation || enteringAnimation
                        : enteringAnimation), animationTimingFunction: animationTimingFunction(state), animationDelay: delay + "ms", animationFillMode: isExiting ? 'forwards' : 'backwards', animationDuration: (isExiting ? duration * EXITING_MOTION_MULTIPLIER : duration) + "ms", animationPlayState: paused ? 'paused' : 'running' }, prefersReducedMotion()))
                : '',
        }, state);
    }));
};
export default EnteringMotion;
//# sourceMappingURL=keyframes-motion.js.map