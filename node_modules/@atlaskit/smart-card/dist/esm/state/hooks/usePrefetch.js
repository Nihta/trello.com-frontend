import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import { useCallback } from 'react';
import { useSmartLinkContext } from '../context';
export function usePrefetch(url) {
  var _useSmartLinkContext = useSmartLinkContext(),
      store = _useSmartLinkContext.store,
      prefetchStore = _useSmartLinkContext.prefetchStore,
      connections = _useSmartLinkContext.connections;

  var dispatch = store.dispatch,
      getState = store.getState;
  var client = connections.client;
  return useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var isPrefetching, isFetching, needsPrefetch, response;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // If the link is already being prefetched, the prefetch store
            // should have a flag set against the URL. The prefetch store is purposefully
            // separate from the UI in order to ensure no rendering takes place;
            // all mutations which occur are purely store-based mutations.
            isPrefetching = prefetchStore[url]; // If the link has already been registered in the store, then it no
            // longer needs to be prefetched, as the normal flow of a link being in
            // the viewport and being fetched is now in motion.

            isFetching = getState()[url]; // We compute if a link needs to be prefetched thus, referencing the above.

            needsPrefetch = !isPrefetching && !isFetching;

            if (!needsPrefetch) {
              _context.next = 14;
              break;
            }

            // We specify in the prefetch store that this link no
            // longer needs to be prefetched. Data which comes back
            // from a successful prefetch flow here will be used to
            // render all URLs which are the same.
            prefetchStore[url] = true; // Try fetch the data for this URL from Object Resolver Service (ORS), executing batch
            // requests by domain (as usual) to ensure we minimize the amount of connections
            // we create between browser -> ORS when making network requests.

            _context.prev = 5;
            _context.next = 8;
            return client.prefetchData(url);

          case 8:
            response = _context.sent;

            // Once the data comes back, we put the link in the `resolved` status. This ensures
            // that when the link enters the viewport and is rendered, we immediately show it as
            // a Smart Link, rather than rendering a loading spinner -> immediate Smart Link.
            if (response) {
              dispatch({
                type: 'resolved',
                url: url,
                payload: response
              });
            }

            _context.next = 14;
            break;

          case 12:
            _context.prev = 12;
            _context.t0 = _context["catch"](5);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 12]]);
  })), [prefetchStore, url, getState, client, dispatch]);
}