import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import { useMemo, useCallback } from 'react';
import { auth } from '@atlaskit/outbound-auth-flow-client';
import { cardAction } from './helpers';
import { getDefinitionId, getByDefinitionId, getServices, getStatus, getExtensionKey } from '../helpers';
import { ACTION_PENDING, ACTION_RESOLVED, ACTION_ERROR, ERROR_MESSAGE_OAUTH, ERROR_MESSAGE_FATAL, ACTION_ERROR_FALLBACK } from './constants';
import { useSmartLinkContext } from '../context';
import * as measure from '../../utils/performance';
import { APIError } from '../../client/errors';
import { getUnauthorizedJsonLd } from '../../utils/jsonld';
export var useSmartCardActions = function useSmartCardActions(id, url, analytics) {
  var _useSmartLinkContext = useSmartLinkContext(),
      store = _useSmartLinkContext.store,
      connections = _useSmartLinkContext.connections,
      config = _useSmartLinkContext.config;

  var getState = store.getState,
      dispatch = store.dispatch;

  var _ref = getState()[url] || {
    status: 'pending',
    lastUpdatedAt: Date.now(),
    details: undefined
  },
      details = _ref.details,
      lastUpdatedAt = _ref.lastUpdatedAt,
      status = _ref.status;

  var hasAuthFlowSupported = config.authFlow !== 'disabled';
  var hasData = !!(details && details.data);
  var hasExpired = Date.now() - lastUpdatedAt >= config.maxAge;
  var handleResolvedLinkError = useCallback(function (url, error) {
    if (error.kind === 'fatal') {
      // If there's no previous data in the store for this URL, then bail
      // out and let the editor handle fallbacks (returns to a blue link).
      if (!hasData && status !== 'resolved') {
        dispatch(cardAction(ACTION_ERROR, {
          url: url
        }, details, error));
        throw error;
      } // If we already have resolved data for this URL in the store, then
      // simply fallback to the previous data.


      if (hasData) {
        dispatch(cardAction(ACTION_RESOLVED, {
          url: url
        }, details));
      } // Handle AuthErrors (user did not have access to resource) -
      // Missing AAID in ASAP claims, or missing UserContext, or 403 from downstream

    } else if (error.kind === 'auth') {
      dispatch(cardAction(ACTION_RESOLVED, {
        url: url
      }, getUnauthorizedJsonLd()));
    } else {
      if (error.kind === 'fallback') {
        // Fallback to blue link with smart link formatting. Not part of reliability.
        dispatch(cardAction(ACTION_ERROR_FALLBACK, {
          url: url
        }, undefined, error));
      } else {
        // Fallback to blue link with smart link formatting. Part of reliability.
        dispatch(cardAction(ACTION_ERROR, {
          url: url
        }, undefined, error));
      }
    }
  }, [hasData, status, dispatch, details]);
  var handleResolvedLinkResponse = useCallback(function (resourceUrl, response) {
    var hostname = new URL(resourceUrl).hostname;
    var nextStatus = response ? getStatus(response) : 'fatal'; // If we require authorization & do not have an authFlow available,
    // throw an error and render as a normal blue link.

    if (nextStatus === 'unauthorized' && !hasAuthFlowSupported) {
      handleResolvedLinkError(resourceUrl, new APIError('fallback', hostname, ERROR_MESSAGE_OAUTH));
      return;
    } // Handle any other errors


    if (nextStatus === 'fatal') {
      handleResolvedLinkError(resourceUrl, new APIError('fatal', hostname, ERROR_MESSAGE_FATAL));
      return;
    } // Dispatch Analytics and resolved card action - including unauthorized states.


    dispatch(cardAction(ACTION_RESOLVED, {
      url: resourceUrl,
      hasExpired: hasExpired && !hasData
    }, response));
  }, [dispatch, handleResolvedLinkError, hasData, hasExpired, hasAuthFlowSupported]);
  var resolve = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var resourceUrl,
        isReloading,
        _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            resourceUrl = _args.length > 0 && _args[0] !== undefined ? _args[0] : url;
            isReloading = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;

            if (!(isReloading || hasExpired || !hasData)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", connections.client.fetchData(resourceUrl).then(function (response) {
              return handleResolvedLinkResponse(resourceUrl, response);
            }).catch(function (error) {
              return handleResolvedLinkError(resourceUrl, error);
            }));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), [url, hasData, hasExpired, connections.client, handleResolvedLinkResponse, handleResolvedLinkError]);
  var register = useCallback(function () {
    if (!details) {
      dispatch(cardAction(ACTION_PENDING, {
        url: url
      }));
    }

    return resolve();
  }, [url, resolve, details, dispatch]);
  var reload = useCallback(function () {
    var definitionId = getDefinitionId(details);

    if (definitionId) {
      getByDefinitionId(definitionId, getState()).map(function (url) {
        return resolve(url, true);
      });
    } else {
      resolve(url, true);
    }
  }, [url, details, getState, resolve]);
  var authorize = useCallback(function (appearance) {
    var definitionId = getDefinitionId(details);
    var extensionKey = getExtensionKey(details);
    var services = getServices(details); // When authentication is triggered, let GAS know!

    if (status === 'unauthorized') {
      analytics.ui.authEvent(appearance, definitionId, extensionKey);
    }

    if (status === 'forbidden') {
      analytics.ui.authAlternateAccountEvent(appearance, definitionId, extensionKey);
    }

    if (services.length > 0) {
      analytics.screen.authPopupEvent(definitionId, extensionKey);
      auth(services[0].url).then(function () {
        analytics.track.appAccountConnected(definitionId, extensionKey);
        analytics.operational.connectSucceededEvent(definitionId, extensionKey);
        reload();
      }, function (err) {
        analytics.operational.connectFailedEvent(definitionId, extensionKey, err.type);

        if (err.type === 'auth_window_closed') {
          analytics.ui.closedAuthEvent(appearance, definitionId, extensionKey);
        }

        reload();
      });
    }
  }, [analytics.ui, analytics.screen, analytics.track, analytics.operational, reload, details, status]);
  var invoke = useCallback( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(opts, appearance) {
      var key, action, source, markName, response;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              key = opts.key, action = opts.action;
              source = opts.source || appearance;
              markName = "".concat(id, "-").concat(action.type); // Begin performance instrumentation.

              measure.mark(markName, 'pending');
              _context2.prev = 4;
              // Begin analytics instrumentation.
              analytics.ui.actionClickedEvent(key, action.type, source); // Invoke action - either client-side or server-side.

              if (!(opts.type === 'client')) {
                _context2.next = 12;
                break;
              }

              _context2.next = 9;
              return opts.action.promise();

            case 9:
              response = _context2.sent;
              _context2.next = 15;
              break;

            case 12:
              _context2.next = 14;
              return connections.client.postData(opts);

            case 14:
              response = _context2.sent;

            case 15:
              measure.mark(markName, 'resolved');
              analytics.operational.invokeSucceededEvent(id, key, action.type, source);
              return _context2.abrupt("return", response);

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](4);
              measure.mark(markName, 'errored');
              analytics.operational.invokeFailedEvent(id, key, action.type, source, _context2.t0.message);
              throw _context2.t0;

            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 20]]);
    }));

    return function (_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }(), [id, analytics.ui, analytics.operational, connections.client]);
  return useMemo(function () {
    return {
      register: register,
      reload: reload,
      authorize: authorize,
      invoke: invoke
    };
  }, [register, reload, authorize, invoke]);
};