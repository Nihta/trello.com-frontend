import { __read } from "tslib";
import { buildActionName } from './eventBuilder';
import EventCompressor from './eventCompressor';
import { equals, partition } from './objectUtils';
// We want to throttle the flush rate so that we don't have a huge upfront performance hit from starting the flush,
// and so that the underlying Segment client has some time to process some events in its queue before more are added.
var FLUSH_BATCH_SIZE = 7; // aligns with the default batch size of Segment's BatchableQueue
var FLUSH_BATCH_BACKOFF_PERIOD = 100;
var EventDelayQueue = /** @class */ (function () {
    function EventDelayQueue(processFn, compressionRules) {
        var _this = this;
        this.push = function (identifier, builtEvent, context, userInfo) {
            _this._eventArgs.push({ identifier: identifier, builtEvent: builtEvent, context: context, userInfo: userInfo });
        };
        this.size = function () { return _this._eventArgs.length; };
        this.startFlush = function () {
            try {
                _this._eventArgs = _this._compressEventArgs(_this._eventArgs);
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.warn('Failed to perform compression on the delayed analytics events. ' +
                    ("Error: " + e.message + ". Sending " + _this._eventArgs.length + " uncompressed events instead"));
            }
            _this._flushNextBatch();
        };
        this.cancelFlush = function () {
            if (_this._flushBatchTimeout) {
                clearTimeout(_this._flushBatchTimeout);
                _this._flushBatchTimeout = null;
            }
        };
        this._flushNextBatch = function () {
            var batch = _this._eventArgs.splice(0, FLUSH_BATCH_SIZE);
            batch.forEach(function (item) { return _this._processFn(item.identifier, item.builtEvent, item.context, item.userInfo); });
            if (_this._eventArgs.length > 0) {
                _this._flushBatchTimeout = setTimeout(function () { return _this._flushNextBatch(); }, FLUSH_BATCH_BACKOFF_PERIOD);
            }
            else {
                _this._flushBatchTimeout = null;
            }
        };
        this._compressEventArgs = function (eventArgs) {
            var _a = __read(partition(eventArgs, function (args) { return _this._compressor.canCompress(args.builtEvent); }), 2), compressibleEventArgs = _a[0], incompressibleEventArgs = _a[1];
            // Events can only be compressed together if they share the same context and user info, since these are top-level
            // fields that need to exist on the fired event and can only be set to a single value.
            // We can achieve this by grouping our events by context prior to passing them to the compressor.
            var contextGroups = compressibleEventArgs.reduce(function (groups, args) {
                var matchingGroup = null;
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    if (equals(group.userInfo, args.userInfo) && equals(group.context, args.context)) {
                        matchingGroup = group;
                        break;
                    }
                }
                if (matchingGroup) {
                    matchingGroup.eventArgs.push(args);
                }
                else {
                    groups.push({
                        userInfo: args.userInfo,
                        context: args.context,
                        eventArgs: [args],
                    });
                }
                return groups;
            }, []);
            // Run the compressor on each group
            var allCompressedEventArgs = contextGroups.reduce(function (acc, group) {
                try {
                    var events = group.eventArgs.map(function (args) { return args.builtEvent; });
                    var compressedEvents = _this._compressor.compress(events);
                    var compressedEventArgs = compressedEvents.map(function (compressedEvent) { return ({
                        identifier: buildActionName(compressedEvent),
                        builtEvent: compressedEvent,
                        userInfo: group.userInfo,
                        context: group.context,
                    }); });
                    compressedEventArgs.forEach(function (args) { return acc.push(args); });
                    return acc;
                }
                catch (e) {
                    // If anything goes wrong while compressing this group, then just fall back on the
                    // uncompressed events instead. The event compressor already handles errors with invalid
                    // generator functions or results, but this is an extra layer of defense to prevent data
                    // loss in the event of an unexpected error.
                    // eslint-disable-next-line no-console
                    console.warn('Failed to compress some analytics events. ' +
                        ("Error: " + e.message + ". Sending " + group.eventArgs.length + " uncompressed events instead"));
                    return group.eventArgs;
                }
            }, []);
            incompressibleEventArgs.forEach(function (args) { return allCompressedEventArgs.push(args); });
            return allCompressedEventArgs;
        };
        this._processFn = processFn;
        this._flushBatchTimeout = null;
        this._eventArgs = [];
        this._compressor = new EventCompressor(compressionRules);
    }
    return EventDelayQueue;
}());
export default EventDelayQueue;
