import { __assign } from "tslib";
import Queue from '@segment/localstorage-retry';
import Scheduler from './Scheduler';
import DuplicateEventDetector from './DuplicateEventDetector';
var DEFAULT_FLUSH_BATCH_SIZE = 7;
// These must all be 1. If they are 0, they will not be truthy and in built defaults will be used.
var QUEUE_RETRY_OPTION_OVERRIDES = {
    minRetryDelay: 1,
    maxRetryDelay: 1,
    backoffFactor: 1,
    backoffJitter: 0,
};
/**
 * Create a queue, backed by localstorage, in which items are processed by the queue in batches
 *
 * @param {Object} options queue options,
 * @param {Function} batchProcessFunc the function to process a batch of items from the queue
 */
var BatchableQueue = /** @class */ (function () {
    function BatchableQueue(retryQueuePrefix, retryQueueOptions, batchProcessFunc) {
        var _this = this;
        this.start = function () {
            _this.queue.start();
        };
        this.getDiscardCounter = function () { return _this.discardCounter; };
        this.getOverflowCounter = function () { return _this.overflowCounter; };
        this.getDuplicateCounter = function () { return _this.duplicateCounter; };
        this.getLocalStorageDuplicateCounter = function () { return _this.localstorageDuplicateCounter; };
        this.getGlobalRetryCount = function () { return _this.scheduler.getFailureCount(); };
        this._flush = function (done) {
            if (_this.currentBatch.length !== 0) {
                var batchedQueuedObjects_1 = _this.currentBatch.splice(0, _this.flushBatchSize);
                var batchedItems_1 = batchedQueuedObjects_1.map(function (queuedItem) { return queuedItem.item; });
                batchedItems_1.forEach(function (item) {
                    /* eslint-disable no-underscore-dangle */
                    if (item.msg && item.msg._metadata && item.msg.messageId) {
                        item.msg._metadata.failedAttempts = _this.messageFailedAttemptCounter[item.msg.messageId] || 0;
                    }
                    /* eslint-enable no-underscore-dangle */
                });
                var messageIds_1 = batchedItems_1.map(function (item) { return item.msg.messageId; });
                _this.batchProcessFunc(batchedItems_1, function (error, response) {
                    // Important to remove the events from the detector before calling done,
                    // otherwise we could accidentally mark it as duplicated
                    _this.duplicateEventDetector.done(error, batchedItems_1);
                    batchedQueuedObjects_1.forEach(function (item) { return item.done(error, response); });
                    done(error);
                    if (!error) {
                        _this.discardCounter = 0;
                        _this.overflowCounter = 0;
                        _this.duplicateCounter = 0;
                        _this.localstorageDuplicateCounter = 0;
                        _this._resetMessageIdCounters(messageIds_1);
                    }
                    else {
                        _this._incrementMessageIdCounters(messageIds_1);
                    }
                    if (_this.currentBatch.length > 0) {
                        _this._schedule();
                    }
                });
            }
            else {
                done();
            }
        };
        this._incrementMessageIdCounters = function (messageIds) {
            messageIds.forEach(function (id) {
                if (_this.messageFailedAttemptCounter[id]) {
                    _this.messageFailedAttemptCounter[id] += 1;
                }
                else {
                    _this.messageFailedAttemptCounter[id] = 1;
                }
            });
        };
        this._resetMessageIdCounters = function (messageIds) {
            messageIds.forEach(function (id) { return delete _this.messageFailedAttemptCounter[id]; });
        };
        this._onDiscardedEvent = function (item) {
            _this.discardCounter += 1;
            delete _this.messageFailedAttemptCounter[item.msg.messageId];
        };
        this._onOverflowEvent = function (item) {
            _this.overflowCounter += 1;
            delete _this.messageFailedAttemptCounter[item.msg.messageId];
        };
        this._onLocalstorageDuplicateEvent = function (item) {
            _this.localstorageDuplicateCounter += 1;
            delete _this.messageFailedAttemptCounter[item.msg.messageId];
        };
        this._schedule = function () {
            _this.scheduler.schedule({
                immediate: _this.currentBatch.length >= _this.flushBatchSize,
            });
        };
        this._processSingleElement = function (item, done) {
            if (_this.duplicateEventDetector.hasEventBeenSeen(item)) {
                done();
                _this.duplicateCounter++;
                return;
            }
            _this.duplicateEventDetector.addItem(item);
            _this.currentBatch.push({
                item: item,
                done: done,
            });
            if (_this.currentBatch.length > _this.maxQueueSize) {
                _this.currentBatch.splice(0, _this.currentBatch.length - _this.maxQueueSize);
            }
            _this._schedule();
        };
        this.addItem = function (item) { return _this.queue.addItem(item); };
        this.stop = function () {
            _this.scheduler.stop();
            _this.queue.stop();
        };
        this.on = function (eventName, callback) { return _this.queue.on(eventName, callback); };
        this.maxQueueSize = retryQueueOptions.maxItems || 500;
        this.queue = new Queue(retryQueuePrefix, __assign(__assign({}, retryQueueOptions), QUEUE_RETRY_OPTION_OVERRIDES), this._processSingleElement);
        this.flushBatchSize = retryQueueOptions.batchFlushSize || DEFAULT_FLUSH_BATCH_SIZE;
        this.batchProcessFunc = batchProcessFunc;
        this.duplicateEventDetector = new DuplicateEventDetector();
        this.currentBatch = [];
        this.scheduler = new Scheduler(__assign(__assign({}, retryQueueOptions), { waitInterval: retryQueueOptions.flushWaitMs }), this._flush);
        this.queue.on('discard', this._onDiscardedEvent);
        this.queue.on('overflow', this._onOverflowEvent);
        this.queue.on('duplication', this._onLocalstorageDuplicateEvent);
        this.discardCounter = 0;
        this.overflowCounter = 0;
        this.duplicateCounter = 0;
        this.localstorageDuplicateCounter = 0;
        this.messageFailedAttemptCounter = {};
    }
    return BatchableQueue;
}());
export default BatchableQueue;
