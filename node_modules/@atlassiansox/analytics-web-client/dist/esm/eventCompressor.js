import { __assign, __read } from "tslib";
import { omit, equals, partition } from './objectUtils';
import { isActionEventType, validateActionEventType, validateActionEvent } from './eventValidation';
import { buildActionFields } from './eventBuilder';
var CompressionRule = /** @class */ (function () {
    /**
     * @callback EventPredicate
     * @param {object} event An analytics event
     * @returns {boolean} A flag indicating whether or not the event matches the conditions
     */
    /**
     * @callback CompressionFunction
     * @param {Array.<Object>} events A collection of analytics events that match the predicate of this compression rule
     * @returns {Array.<Object>} compressedEvents The compressed analytics events to fire
     */
    /**
     * This constructor defines a new rule for compressing analytics events.
     * @param {EventPredicate} predicate
     * @param {CompressionFunction} compressFn
     */
    function CompressionRule(predicate, compressFn) {
        var _this = this;
        /**
         * This function returns a flag indicating whether or not this instance is capable of compressing the given event.
         * @param event
         * @returns {boolean}
         */
        this.canCompress = function (event) {
            try {
                return event && isActionEventType(event.eventType) && _this._predicate(event);
            }
            catch (e) {
                return false;
            }
        };
        /**
         * This function compresses as many events in the given collection as possible.<p>
         * Any events in the given collection that do not match the conditions of {@link canCompress} will be left uncompressed and
         * appended to the end of the resulting array.
         *
         * @param events A collection of analytic events to compress
         * @returns {Array.<Object>} The action fields for the resulting compressed events
         */
        this.compress = function (events) {
            var _a = __read(partition(events, function (event) { return _this.canCompress(event); }), 2), compatibleEvents = _a[0], incompatibleEvents = _a[1];
            var compressedEvents = _this._compressFn(compatibleEvents);
            if (!compressedEvents) {
                throw new Error('No events were returned from the compression function');
            }
            compressedEvents.forEach(function (event) {
                validateActionEventType(event.eventType);
                validateActionEvent(event);
            });
            return compressedEvents.concat(incompatibleEvents);
        };
        if (typeof predicate !== 'function') {
            throw new Error('Invalid predicate, must be a function that accepts an event and returns a boolean');
        }
        if (typeof compressFn !== 'function') {
            throw new Error('Invalid compressFn, must be a function that both accepts and returns an array of events');
        }
        this._predicate = predicate;
        this._compressFn = compressFn;
    }
    return CompressionRule;
}());
export { CompressionRule };
var EventCompressor = /** @class */ (function () {
    function EventCompressor(compressionRules) {
        var _this = this;
        if (compressionRules === void 0) { compressionRules = []; }
        this.canCompress = function (event) { return _this._compressionRules.some(function (compressionRule) { return compressionRule.canCompress(event); }); };
        this.compress = function (events) {
            var groups = _this._createGroups(events);
            return groups.reduce(function (allCompressedEvents, group) {
                var groupCompressedEvents = _this._compressGroup(group);
                groupCompressedEvents.forEach(function (compressedEvent) { return allCompressedEvents.push(compressedEvent); });
                return allCompressedEvents;
            }, []);
        };
        this._createGroups = function (events) {
            // Group events based on contextual fields. These fields are anything that is added by the client itself,
            // rather than passed in by the caller (eg. product, org. and tenant info)
            return events.reduce(function (groups, event) {
                var matchingCompressor = null;
                for (var i = 0; i < _this._compressionRules.length; i++) {
                    var compressor = _this._compressionRules[i];
                    if (compressor.canCompress(event)) {
                        matchingCompressor = compressor;
                        break;
                    }
                }
                var contextFields;
                if (matchingCompressor) {
                    var actionFields = buildActionFields(event, event.eventType);
                    contextFields = omit(event, Object.keys(actionFields));
                }
                var matchingGroup = null;
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    if (matchingCompressor === group.compressor && equals(contextFields, group.contextFields)) {
                        matchingGroup = group;
                        break;
                    }
                }
                if (matchingGroup) {
                    matchingGroup.events.push(event);
                }
                else {
                    groups.push({
                        contextFields: contextFields,
                        compressor: matchingCompressor,
                        events: [event],
                    });
                }
                return groups;
            }, []);
        };
        this._compressGroup = function (group) {
            // If this group doesn't have any compressor, then the event args are already in their final format
            if (!group.compressor) {
                return group.events;
            }
            try {
                // Run the compressor on the group to generate some new events.
                // The compression function is only expected to return the action fields for each
                // event that it generates, since all other fields are generated by the client.
                var compressedEventActionFields = group.compressor.compress(group.events);
                // Add the context fields to each of the resulting events to inflate them into a full action event
                return compressedEventActionFields.map(function (actionFields) { return (__assign(__assign({}, actionFields), group.contextFields)); });
            }
            catch (e) {
                // If we fail to compress the events, then just fall back the uncompressed events
                // so that no data is lost. This can happen if the compression function throws an error
                // or returns some invalid event payloads.
                // eslint-disable-next-line no-console
                console.warn('Failed to compress some analytics events. ' +
                    ("Error: " + e.message + ". Sending " + group.events.length + " uncompressed events instead"));
                return group.events;
            }
        };
        if (!Array.isArray(compressionRules)) {
            throw new Error('Event compressors must be constructed with an array of CompressionRules');
        }
        if (!compressionRules.every(function (rule) { return rule instanceof CompressionRule; })) {
            throw new Error('Event compressors can only be constructed with instances of CompressionRule');
        }
        this._compressionRules = compressionRules;
    }
    return EventCompressor;
}());
export default EventCompressor;
