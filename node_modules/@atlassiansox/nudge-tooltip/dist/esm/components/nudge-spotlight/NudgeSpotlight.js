import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useState, useCallback, useRef, useEffect, forwardRef } from 'react'; // eslint-disable-line import/no-extraneous-dependencies

import Tooltip from '@atlaskit/tooltip';
import { NudgeSpotlightPrimitive } from './styled';
import { NudgeTooltipPulse } from '../shared/styled';
import { withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import { onRenderPayload, onShowPayload, onHidePayload, onClickPayload, onOutsideClickPayload } from './analyticPayloads';
import { SpotlightCard } from '@atlaskit/onboarding'; // eslint-disable-next-line import/no-extraneous-dependencies

import debounce from 'lodash/debounce';
var oneYear = 31556952000; // eslint-disable-next-line react/display-name

var SpotlightCardContent = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var setSpotlightMounted = _ref.setSpotlightMounted,
      setDelayValue = _ref.setDelayValue,
      children = _ref.children,
      spotlightCardProps = _objectWithoutProperties(_ref, ["setSpotlightMounted", "setDelayValue", "children"]);

  useEffect(function () {
    setDelayValue(oneYear);
    setSpotlightMounted(true);
    return function () {
      setDelayValue(0);
      setSpotlightMounted(false);
    };
  }, [setDelayValue, setSpotlightMounted]);
  return /*#__PURE__*/React.createElement(SpotlightCard, _extends({
    ref: ref
  }, spotlightCardProps), children);
});

var NudgeSpotlight = function NudgeSpotlight(_ref2) {
  var _ref2$onRender = _ref2.onRender,
      onRender = _ref2$onRender === void 0 ? function () {} : _ref2$onRender,
      _ref2$onShow = _ref2.onShow,
      onShow = _ref2$onShow === void 0 ? function () {} : _ref2$onShow,
      _ref2$onHide = _ref2.onHide,
      onHide = _ref2$onHide === void 0 ? function () {} : _ref2$onHide,
      _ref2$onClick = _ref2.onClick,
      onClick = _ref2$onClick === void 0 ? function () {} : _ref2$onClick,
      _ref2$onOutsideClick = _ref2.onOutsideClick,
      onOutsideClick = _ref2$onOutsideClick === void 0 ? function () {} : _ref2$onOutsideClick,
      _ref2$setHidden = _ref2.setHidden,
      setRemoteHidden = _ref2$setHidden === void 0 ? function () {} : _ref2$setHidden,
      children = _ref2.children,
      content = _ref2.content,
      remoteHidden = _ref2.hidden,
      _ref2$hideNudgeOnClic = _ref2.hideNudgeOnClick,
      hideNudgeOnClick = _ref2$hideNudgeOnClic === void 0 ? true : _ref2$hideNudgeOnClic,
      _ref2$hideSpotlightOn = _ref2.hideSpotlightOnOutsideClick,
      hideSpotlightOnOutsideClick = _ref2$hideSpotlightOn === void 0 ? false : _ref2$hideSpotlightOn,
      _ref2$autoShow = _ref2.autoShow,
      autoShow = _ref2$autoShow === void 0 ? true : _ref2$autoShow,
      _ref2$zIndex = _ref2.zIndex,
      zIndex = _ref2$zIndex === void 0 ? -1 : _ref2$zIndex,
      position = _ref2.position,
      spotlightCardProps = _objectWithoutProperties(_ref2, ["onRender", "onShow", "onHide", "onClick", "onOutsideClick", "setHidden", "children", "content", "hidden", "hideNudgeOnClick", "hideSpotlightOnOutsideClick", "autoShow", "zIndex", "position"]);

  var nudgeRef = useRef(null);
  var spotlightRef = useRef(null);

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      delayValue = _useState2[0],
      setDelayValue = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      optimisticHide = _useState4[0],
      setOptimisticHide = _useState4[1];

  var _useState5 = useState(!autoShow),
      _useState6 = _slicedToArray(_useState5, 2),
      hideWasExpected = _useState6[0],
      setHideWasExpected = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      spotlightMounted = _useState8[0],
      setSpotlightMounted = _useState8[1];

  var _useState9 = useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      atLeastOneRender = _useState10[0],
      setAtLeastOneRender = _useState10[1];

  var overallHidden = optimisticHide || !!remoteHidden;
  var textContent = !overallHidden && content;
  var programmaticSpotlightToggle = useCallback(function (value) {
    if (!nudgeRef.current) {
      return;
    }

    var isShow = value === 'show',
        isHide = value === 'hide';
    var eventName = isShow ? 'mouseover' : 'mouseout';
    setHideWasExpected(isHide);
    setDelayValue(0);
    nudgeRef.current.dispatchEvent(new MouseEvent(eventName, {
      view: window,
      bubbles: true,
      cancelable: true
    }));
  }, [setHideWasExpected, setDelayValue]); // Used when reviving spotlight during scrolling
  // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var debouncedSpotlightToggle = useCallback(debounce(programmaticSpotlightToggle, 1000, {
    leading: true,
    trailing: true
  }), [programmaticSpotlightToggle]); // Needed bc tooltip onShow callback does not fire predictably
  // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var debouncedOnShow = useCallback(debounce(onShow, 100, {
    trailing: true
  }), [onShow]);
  var hideNudgeAndSpotlight = useCallback(function () {
    programmaticSpotlightToggle('hide');
    setOptimisticHide(true);
    setRemoteHidden();
  }, [programmaticSpotlightToggle, setRemoteHidden]);
  var onShowHandler = useCallback(function () {
    setHideWasExpected(false);
    debouncedOnShow();
  }, [debouncedOnShow]);
  var handleInsideClick = useCallback(function () {
    if (overallHidden) {
      return;
    }

    onClick();

    if (hideNudgeOnClick) {
      hideNudgeAndSpotlight();
    }
  }, [overallHidden, onClick, hideNudgeOnClick, hideNudgeAndSpotlight]); // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var renderSpotlightCard = useCallback( /*#__PURE__*/forwardRef(function (_ref3, ref) {
    var children = _ref3.children,
        rest = _objectWithoutProperties(_ref3, ["children"]);

    return textContent ? /*#__PURE__*/React.createElement(NudgeSpotlightPrimitive, _extends({}, rest, {
      innerRef: ref
    }), /*#__PURE__*/React.createElement(SpotlightCardContent, _extends({
      setDelayValue: setDelayValue,
      setSpotlightMounted: setSpotlightMounted,
      ref: spotlightRef
    }, spotlightCardProps), children)) : null;
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [textContent]); // Callback fired on global 'click' to detect if it happened outside of nudge

  var handleGlobalClick = useCallback(function (evt) {
    var nudgeRing = nudgeRef.current;
    var spotlight = spotlightRef.current;
    var clickTarget = evt.target;

    if (overallHidden) {
      return;
    }

    if (!hideSpotlightOnOutsideClick) {
      return;
    }

    if (!nudgeRing) {
      return;
    }

    if (!clickTarget) {
      return;
    }

    if (!spotlight) {
      return;
    }

    if (nudgeRing.contains(clickTarget)) {
      return;
    }

    if (spotlight.contains(clickTarget)) {
      return;
    }

    programmaticSpotlightToggle('hide');
    onOutsideClick();
  }, [overallHidden, hideSpotlightOnOutsideClick, programmaticSpotlightToggle, onOutsideClick]);
  var setOneYearDelay = useCallback(function () {
    if (overallHidden) {
      return;
    }

    if (hideWasExpected) {
      return;
    }

    if (!spotlightMounted) {
      return;
    }

    setDelayValue(oneYear);
  }, [hideWasExpected, spotlightMounted, overallHidden]); // When spotlight is mounted and an actual mouseout of the nudgeRing happens
  // AK attempts to remove the tooltip. This prevents it.

  useEffect(function () {
    var nudgeRing = nudgeRef.current;

    if (!nudgeRing) {
      return;
    }

    nudgeRing.addEventListener('mouseout', setOneYearDelay);
    return function () {
      return nudgeRing.removeEventListener('mouseout', setOneYearDelay);
    };
  }, [setOneYearDelay]); // Needed Delay Cleanup after remoteHidden becomes true
  // Sometimes debounced programmaticShowToggle gets dispatched after hiding the nudge
  // If not for this fix, delay gets set to oneYear and then if nudge is shown again
  // The spotlight won't appear automatically because of the lingering oneYear delay

  useEffect(function () {
    if (!delayValue) {
      return;
    }

    if (!remoteHidden) {
      return;
    }

    setDelayValue(0);
  }, [delayValue, remoteHidden]); // Reset optimistic hide when remote gets hidden and fire callback
  // If no renders happened we skip it, bc remoteHidden started out as hidden

  useEffect(function () {
    if (!remoteHidden) {
      return;
    }

    programmaticSpotlightToggle('hide');

    if (!atLeastOneRender) {
      return;
    }

    setAtLeastOneRender(false);
    setOptimisticHide(false);
    onHide();
  }, [remoteHidden, atLeastOneRender, setAtLeastOneRender, programmaticSpotlightToggle, onHide]); // Auto-show Effect

  useEffect(function () {
    if (overallHidden) {
      return;
    }

    if (!autoShow) {
      return;
    }

    programmaticSpotlightToggle('show');
    debouncedOnShow();
  }, [overallHidden, autoShow, programmaticSpotlightToggle, debouncedOnShow]); // Render Nudge Ring Effect

  useEffect(function () {
    if (overallHidden) {
      return;
    }

    setAtLeastOneRender(true);
    onRender();
  }, [onRender, overallHidden]); // Effect to revive spotlight if no closure was expected
  // This happens when AK tries to de-conflict spotlights

  useEffect(function () {
    if (overallHidden) {
      return;
    }

    if (spotlightMounted) {
      return;
    }

    if (hideWasExpected) {
      return;
    }

    debouncedSpotlightToggle('show');
  }, [overallHidden, spotlightMounted, hideWasExpected, debouncedSpotlightToggle]); // Register and de-register global click callback

  useEffect(function () {
    if (overallHidden) {
      return;
    }

    setImmediate(function () {
      return window.addEventListener('click', handleGlobalClick);
    });
    return function () {
      return window.removeEventListener('click', handleGlobalClick);
    };
  }, [overallHidden, handleGlobalClick]); // Set desired zIndex

  useEffect(function () {
    if (zIndex === -1) {
      return;
    }

    if (spotlightRef.current === null) {
      return;
    }

    var current = spotlightRef.current;

    while (current) {
      if (current.classList.contains('atlaskit-portal')) {
        break;
      }

      current = current.parentNode;
    }

    if (!current) {
      return;
    }

    current.style.zIndex = "".concat(zIndex); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [spotlightRef.current, zIndex]);
  return /*#__PURE__*/React.createElement(Tooltip, {
    hideTooltipOnClick: hideNudgeOnClick,
    hideTooltipOnMouseDown: false,
    delay: delayValue,
    component: renderSpotlightCard,
    content: textContent,
    onShow: onShowHandler,
    position: position
  }, /*#__PURE__*/React.createElement(NudgeTooltipPulse, {
    hasPulse: !overallHidden,
    innerRef: nudgeRef,
    onClickCapture: handleInsideClick
  }, children));
};

export default withAnalyticsContext({
  componentName: 'NudgeSpotlight'
})(withAnalyticsEvents({
  onRender: _objectSpread({}, onRenderPayload),
  onShow: _objectSpread({}, onShowPayload),
  onHide: _objectSpread({}, onHidePayload),
  onClick: _objectSpread({}, onClickPayload),
  onOutsideClick: _objectSpread({}, onOutsideClickPayload)
})(NudgeSpotlight));