import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useState, useCallback, forwardRef } from 'react';
import Tooltip from '@atlaskit/tooltip';
import { NudgeTooltipPrimitive } from './styled';
import { NudgeTooltipPulse } from '../shared/styled';
import { withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import { onClickPayload, onHidePayload, onShowPayload } from './analyticPayloads';
import { once } from './utils';

var NudgeTooltip = function NudgeTooltip(_ref) {
  var _ref$onShow = _ref.onShow,
      _onShow = _ref$onShow === void 0 ? function () {} : _ref$onShow,
      _ref$onHide = _ref.onHide,
      onHide = _ref$onHide === void 0 ? function () {} : _ref$onHide,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
      children = _ref.children,
      content = _ref.content,
      hidden = _ref.hidden,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 0 : _ref$delay,
      _ref$hideTooltipOnCli = _ref.hideTooltipOnClick,
      hideTooltipOnClick = _ref$hideTooltipOnCli === void 0 ? true : _ref$hideTooltipOnCli,
      _ref$minReadTime = _ref.minReadTime,
      minReadTime = _ref$minReadTime === void 0 ? 1000 : _ref$minReadTime,
      rest = _objectWithoutProperties(_ref, ["onShow", "onHide", "onClick", "children", "content", "hidden", "delay", "hideTooltipOnClick", "minReadTime"]);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasNudged = _useState2[0],
      setNudgedState = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      minReadTimeout = _useState4[0],
      setMinReadTimeout = _useState4[1];

  var hideNudge = hasNudged || !!hidden;
  var textContent = !hideNudge && content;
  var clearMinReadTimeout = useCallback(function () {
    if (minReadTimeout) {
      clearTimeout(minReadTimeout);
    }

    setMinReadTimeout(null);
  }, [minReadTimeout]); // we call this from onClick and onHide
  // it only needs to run the code once
  // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var markDoneOnce = useCallback(once(function () {
    setNudgedState(true);
    onHide();
  }), []); // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var onClickOnce = useCallback(once(function () {
    return onClick();
  }), []);
  var handleClick = useCallback(function () {
    if (hideNudge) {
      return;
    }

    if (hideTooltipOnClick) {
      onClickOnce();
      markDoneOnce();
    } else {
      onClick();
    }
  }, [hideNudge, hideTooltipOnClick, onClickOnce, markDoneOnce, onClick]); // AFP-2511 TODO: Fix automatic suppressions below
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var component = useCallback( /*#__PURE__*/forwardRef(function (props, ref) {
    return /*#__PURE__*/React.createElement(NudgeTooltipPrimitive, _extends({}, props, {
      innerRef: ref
    }));
  }), []);
  return /*#__PURE__*/React.createElement(Tooltip, _extends({
    hideTooltipOnClick: hideTooltipOnClick,
    component: component,
    delay: delay,
    onShow: function onShow() {
      _onShow();

      if (minReadTimeout) {
        clearMinReadTimeout();
      } // @ts-ignore


      setMinReadTimeout(setTimeout(clearMinReadTimeout, minReadTime));
    },
    onHide: function onHide() {
      if (minReadTimeout === null) {
        markDoneOnce();
      }
    },
    content: textContent
  }, rest), /*#__PURE__*/React.createElement(NudgeTooltipPulse, {
    hasPulse: !hideNudge,
    onClickCapture: handleClick
  }, children));
};

export default withAnalyticsContext({
  componentName: 'NudgeTooltip'
})(withAnalyticsEvents({
  onHide: _objectSpread({}, onHidePayload),
  onShow: _objectSpread({}, onShowPayload),
  onClick: _objectSpread({}, onClickPayload)
})(NudgeTooltip));